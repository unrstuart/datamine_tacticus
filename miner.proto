syntax = "proto2";

package dataminer;

message Rank {
  enum Enum {
    UNKNOWN_RANK = 0;
    STONE_1 = 1; // Stone 1
    STONE_2 = 2; // Stone 2
    STONE_3 = 3; // Stone 3
    IRON_1 = 4; // Iron 1
    IRON_2 = 5; // Iron 2
    IRON_3 = 6; // Iron 3
    BRONZE_1 = 7; // Bronze 1
    BRONZE_2 = 8; // Bronze 2
    BRONZE_3 = 9; // Bronze 3
    SILVER_1 = 10; // Silver 1
    SILVER_2 = 11; // Silver 2
    SILVER_3 = 12; // Silver 3
    GOLD_1 = 13; // Gold 1
    GOLD_2 = 14; // Gold 2
    GOLD_3 = 15; // Gold 3
    DIAMOND_1 = 16; // Diamond 1
    DIAMOND_2 = 17; // Diamond 2
    DIAMOND_3 = 18; // Diamond 3
    ADAMANTINE_1 = 19; // Adamantine 1
  }
}

// battleSets.legendary_event_<int>_lane_<1-3>
message LegendaryEvent {
  message Battle {
    message Objective {
      optional string type = 1; // objectiveType
      optional string target = 2; // objectiveTarget
      optional int32 points = 3; // score
    }
    message Wave {
      repeated string enemies = 1; // army
      optional int32 power = 2; // power
      optional int32 round = 3; // round
    }
    optional int32 number = 1; // battleNr
    optional string map_id = 2; // boardId
    optional string disallowed_factions = 3; // disallowedFactions
    optional int32 power = 4; // power
    optional int32 tier = 5;  // tier
    repeated Wave waves = 6; // waves
  }
}

// battleSets.campaigns.(Elite|EliteMirror|Mirror|Standard|Event)[index]
message Campaign {
  // battes[index]
  message Battle {
    message GuaranteedRewardItem {
      optional string id = 1;
      optional int32 min = 2;
      optional int32 max = 3;
    }
    message PotentialRewardItem {
      optional string id = 1;
      optional int32 chance_numerator = 2;
      optional int32 chance_denominator = 3;
      // We use a raid simulation to gather the effective drop
      // rate. Essentially, every time you fail to get a reward,
      // the mercy system reduces the change denominator by 1.
      // Thus, when the numerator and denominator are equal, you
      // are guaranteed to get the reward. We run a simulation
      // of 1B raids to determine the effective drop rate.
      optional float effective_rate = 4;
    }
    message Reward {
      repeated GuaranteedRewardItem base = 1; // base
      optional PotentialRewardItem chance_of = 2; // chanceOf
      optional string star1 = 3; // star1
      optional string star2 = 4; // star2
      optional string star3 = 5; // star3

      // The medal rewards aren't in the battle, I still
      // need to find them.

      optional string bronze_medal = 6; // type = "bronze"
      optional string silver_medal = 7; // type = "silver"
      optional string gold_medal = 8; // type = "gold"
    }
    // units
    optional string id = 1; // battleId
    optional string boss = 12; // boss
    optional int32 lightning_victory = 4; // lightningVictory
    optional Reward reward = 5; // loot
    optional int32 max_attempts = 6; // maxAttempts
    optional int32 spawn_points = 9; // spawnpoints
    optional int32 energy_cost = 10; // staminaCost
    repeated string required_units = 13; // requiredUnits

    // The format is 'id:level'. The level can be retrieved
    // from the npcs object.
    repeated string enemies = 11; // units
  }
  optional string id = 1; // id
  repeated Battle battles = 2; // battles
  repeated string allowed_factions = 3; // unlockConditions.requiredUnits.allowedFactions
}

// battles.campaigns
message Battles {
  repeated Campaign standard_campaigns = 1; // campaigns.Standard
  repeated Campaign elite_campaigns = 2; // campaigns.Elite
  repeated Campaign mirror_campaigns = 3; // campaigns.Mirror
  repeated Campaign mirror_elite_campaigns = 4; // campaigns.EliteMirror
  repeated Campaign campaign_events = 5; // campaigns.Event
}

// globalValues
message GlobalValues {
  repeated string supported_units = 1; // supportedUnits
  repeated string unlockable_factions = 2; // unlockableFactions
}

// itemStatCapMultipliers
message ItemStatCapMultipliers {
  repeated int32 common = 1; // common
  repeated int32 uncommon = 2; // uncommon
  repeated int32 rare = 3; // rare
  repeated int32 epic = 4; // epic
  repeated int32 legendary = 5; // legendary
  repeated int32 mythic = 6; // mythic
}

// items[index]
message Item {
  message Stats {
    optional int32 block_chance = 1; // blockChance
    optional int32 block_damage = 2; // blockDamage
    optional int32 fixed_armor = 3; // fixedArmor
    optional int32 hp = 4; // hp
  }
  message Level {
    optional int32 salvage_cost = 1; // dustCost
    optional int32 gold_cost = 2; // goldCost
    optional Stats stats = 3; // stats
    optional int32 mythic_salvage_cost = 4; // mythicDustCost
  }
  optional string id = 1; // the id of the object
  optional string rarity = 2; // rarity
  repeated string allowed_factions = 3; // allowedFactions
  optional string equipment_type = 4; // itemType
  repeated Level levels = 5; // levels
  optional string next_in_series = 6; // nextInSeries
  optional string ability_id = 7; // abilityId
  optional bool is_relic = 8; // isRelic
  optional bool is_unique_relic = 9; // isUniqueRelic
  repeated string allowed_units = 10; // allowedUnits
}

message Achievement {
  message Milestone {
    optional int32 goal = 1;
    optional string reward = 2;
  }
  optional string id = 1;
  optional string task_id = 2;
  repeated Milestone milestones = 3;
}

message Unit {
  message Stats {
    optional int32 damage = 1; // Damage
    optional int32 armor = 2; // FixedArmor
    optional int32 health = 3; // Health
    optional int32 progression_index = 5; // ProgressionIndex
  }
  message Attack {
    optional string damage_type = 1; // DamageProfile
    optional int32 hits = 2; // hits
    optional int32 range = 3; // Range
  }
  // upgrades
  message RankUpRequirements {
    optional string top_row_health = 1;  // upgrades[0]
    optional string top_row_armor = 2;  // upgrades[2]
    optional string top_row_damage = 3;  // upgrades[4]
    optional string bottom_row_health = 4;  // upgrades[1]
    optional string bottom_row_armor = 5;  // upgrades[3]
    optional string bottom_row_damage = 6;  // upgrades[5]
  }
  optional string id = 1; // the id of the unit
  optional string base_rarity = 2; // BaseRarity
  optional string faction_id = 3; // FactionId
  optional string alliance = 4; // GrandAllianceId
  optional int32 movement = 5; // Movement
  repeated string active_abilities = 6; // activeAbilities
  repeated string passive_abilities = 20; // passiveAbilities
  // eligibilityRequirements
  repeated string equipment_slots = 7; // itemSlots
  repeated int32 item_slots_relic = 8; // itemSlotsRelic
  optional string name = 9; // name
  optional string full_name = 18; // from i18n file
  optional string short_name = 15; // from i18n file
  optional string extra_short_name = 16; // from i18n file
  optional string title = 17; // from i18n file
  optional string description = 19; // from i18n file
  optional Stats stats = 10; // stats
  repeated string traits = 11; // traits
  repeated RankUpRequirements rank_up_requirements = 12; // upgrades
  // upgradesStatIncrease
  optional Attack melee_attack = 13; // weapons[0]
  optional Attack ranged_attack = 14; // weapons[1]
}

message Npc {
  message Stats {
    optional int32 level = 1; // AbilityLevel
    optional int32 damage = 2; // Damage
    optional int32 armor = 3; // FixedArmor
    optional int32 health = 4; // Health
    optional int32 progression_index = 5; // ProgressionIndex
    optional int32 rank = 6; // Rank
    optional int32 stars = 7; // StarLevel    
  }
  optional string id = 1;  // the object id
  optional string faction_id = 2; // FactionId
  optional string alliance = 3; // GrandAllianceId
  optional int32 movement = 4; // Movement
  repeated string active_abilities = 5; // activeAbilities
  optional string name = 6; // name
  repeated string passive_abilities = 7; // passiveAbilities
  repeated string traits = 8; // traits
  optional string visual_id = 9; // visualId
  repeated Stats stats = 10; // stats
}

message MachineOfWar {
  // abilities.<id>
  message Ability {
    optional string name = 1; // <id>
    // [x]
    message UpgradeRecipe {
      optional string mat1 = 1; // [0]
      optional string mat2 = 2; // [1]
      optional string mat3 = 3; // [2]
    }
    repeated UpgradeRecipe upgrade_recipes = 2; // upgrades
  }
  optional string id = 1;
  optional string faction_id = 2; // FactionId
  optional string alliance = 3; // GrandAllianceId
  optional Ability active_ability = 5; // activeAbilities[0]
  optional Ability passive_ability = 6; // activeAbilities[1]
  optional string name = 7;
  optional string short_name = 8;
  optional string title = 10;
}

message MachineOfWarUpgradeCosts {
  message Badges {
    optional string rarity = 1;
    optional int32 amount = 2;
  }
  optional int32 gold = 1; // gold
  optional int32 salvage = 2; // salvage
  optional Badges badges = 3; // badges
  optional int32 components = 4; // components
  optional Badges forge_badges = 5; // forgeBadges
}

message Units {
  message DamagePierceRatio {
    optional string id = 1; // the id of the array element
    optional int32 pierce_ratio = 2; // PiercingRatio
    repeated string traits = 3; // traits - this should be an enum
  }
  message Ability {
    optional string id = 1; // the id of the ability
    repeated string damage_types = 2; // damageTypes
    // we're skipping a lot here, but this gets us the basics.
  }
  repeated Ability abilities = 1; // abilities
  // abilityPowerCurve
  // abilityPowerModifiers
  // abilityUpgradeCosts (gold and badges)
  repeated MachineOfWarUpgradeCosts mow_upgrade_costs = 9; // abilityUpgradeCostsMoW (gold, salvage, badges, components, forge badges)
  // repeated DamagePierceRatio damage_profile_modifiers = 1; // damageProfileModifiers
  // heroProgressionSteps
  // heroProgressionStepsMoW
  // heroProgressionStepsPerUnit
  repeated Unit units = 2; // lineup
  repeated MachineOfWar mows = 8; // machineOfWar

  repeated Npc npcs = 3; // npc
  // skip sortings
  // summons
  // skip traitPowerModifiers
  // skip upgradeSlots
  // skip useShardsToUnlockUnits

  repeated int64 xp_levels = 7; // xpLevels
}

message Upgrades {
  message Upgrade {
    message Recipe {
      message Ingredient {
        optional string id = 1; // id
        optional int32 amount = 2; // amount
      }
      repeated Ingredient ingredients = 1; // list of ingredients
    }
    optional string id = 1; // id of the object
    optional int32 gold = 2; // gold (cost to apply?)
    optional string name = 3; // name
    optional string rarity = 4; // rarity
    optional string stat_type = 5; // statType
    optional Recipe recipe = 6; // crafting
  }
  repeated Upgrade upgrades = 1; // [index]
}

message Avatars {
  message Avatar {
    optional string id = 1; // avatarId
    optional string unit_id = 2; // value
  }
  repeated Avatar avatars = 1; // avatars
}

message ClientGameConfig {
  repeated Achievement achievements = 1;
  // skip aiUtilities
  optional Avatars avatars = 8; // avatars
  optional Battles battles = 2;
  // skip boardsToInclude
  // skip consumables
  // skip defeatTips
  // skip dialogues
  // skip featureIntros
  // skip filters
  optional GlobalValues global_values = 3;
  // skip guilds
  optional ItemStatCapMultipliers item_stat_cap_multipliers = 4;
  repeated Item items = 5;  
  // skip liveEvents
  // skip loot for now, but come back to it, all the chests are there.
  // skip loyalty
  // skip onlineFeatures
  // skip player (themes, avatars, power levels, and referral milestones)

  // skips quests for now, but come back to it since things like LE missions
  // are in there. Look in quests.groups.

  // skip resourceCrafting, it's about forging e.g. badges and orbs.
  // skip shop
  // skip subscriptions
  // skip summoningPortal
  // skip timedReminders
  // skip tips (things like high-grass)

  optional Units units = 6; // units
  optional Upgrades upgrades = 7; // upgrades
}

message GameConfig {
  optional ClientGameConfig client_game_config = 1;
  optional string client_game_config_version = 2;
  optional bool full_config = 3;
  optional string full_config_hash = 4;
}
